---
title: Rczne czenie drzew genealogicznych rcznie, czyli dlaczego straciem tydzie 偶ycia
ownExcerpt: Historia o tym, dlaczego chatGPT przyzna mi tytu "Wadcy Zwoj贸w, Pogromcy Kolizji, Stra偶nika Niezawizanych Linii Krwi"
tags: [IT, programowanie, genealogia]
langs:
    en: gedcom-merge
---

## Jak to si zaczo

Pitek wiecz贸r, na ekranie laptopa wida drzewo genealogiczne prapraprapra...dziadka, obok, zdecydowanie za blisko laptopa stoi zimny kufel piwa (albo parujcy kubek gorcej czekolady, nie oceniam), istna sielanka. Zapisujesz plik, zamykasz okna i nagle orientujesz si, 偶e zamiast na najnowszej wersji drzewa z pendrive'a, od kilku tygodni pracujesz na starej wersji z dysku twardego. Szybkie por贸wnanie - w jednym 200 os贸b wicej, ale przecie偶 r贸偶nic mo偶e by znacznie wicej. Jak do tego doszo? https://youtu.be/_1jxykAEjuY 

## Dlaczego to problem czyli kilka s贸w o formacie GEDCOM

GEDCOM to format plik贸w, kt贸ry pozwala na wymian danych genealogicznych pomidzy r贸偶nymi programami. Jest to format tekstowy, kt贸ry przechowuje informacje o osobach, rodzinach, wydarzeniach i relacjach midzy nimi. Stworzony przez Koci贸 Jezusa Chrystusa witych w Dniach Ostatnich (Mormon贸w) w latach 80-tych XX wieku, jest obecnie de-facto standardem w genealogii, na kt贸rym opieraj si praktycznie wszystkie programy i witryny genealogiczne. Pliki GEDCOM maj rozszerzenie `.ged` i s formatem tekstowym (czytelne dla ludzi), co uatwia ich edycj i przegldanie, ale te偶 umo偶liwia atwe wprowadzanie bd贸w.

Ze wzgldu na swoj prostot, programom genealogicznym cizko jest wykry, 偶e dwa pliki zawieraj te same osoby, ale w r贸偶nych wersjach. W praktyce oznacza to, 偶e 偶aden program nie potrafi bezbdnie poczy dw贸ch wersji tego samego drzewa, mimo 偶e potrafi poczy dwa drzewa w jedno (w tym przypadku z olbrzymi liczb zduplikowanych os贸b i wydarze) oraz wyszuka i poczy potencjalne duplikaty - jednak mo偶na w ten spos贸b sporo namiesza i straci cz informacji, a w dodatku nie mie pewnoci, 偶e wszystkie duplikaty zostay znalezione.

## Co dokadnie poszo nie tak?

W moim przypadku, ze wzgldu na prac na kilku komputerach, trzymaem drzewo wraz z materiaami 藕r贸dowymi na ka偶dym komputerze osobno, a nastpnie kopiowaem je na pendrive'a. Oczywicie lepiej byoby pracowa zawsze tylko na wersji z pendrive'a lub u偶ywa chmury, ale... W sumie nie ma ale. Mdry Polak po szkodzie jak to m贸wi 

W moim przypadku praca nad oboma plikami niezale偶nie trwaa 4 miesice; w obu plikach pojawiay si nowe osoby i rodziny, a tak偶e dodawane byy informacje o istniejcych ju偶 osobach. Oznaczao to konieczno por贸wnania zmian i rcznego zdecydowania kt贸ra zmiana w kt贸rej wersji powinna zosta.

## Od czego zacz

Zacznijmy od sprawdzenia jak bardzo jest 藕le. Plik GEDCOM ma okrelon struktur, ale kolejno danych oraz stosowane identyfikatory obiekt贸w (os贸b, rodzin, notatek, 藕r贸de, itd) zale偶y od u偶ywanego programu. U偶ywany przeze mnie [GEDKeeper](https://gedkeeper.net/) zapisuje wszystko w kolejnoci stworzenia, co oznacza 偶e obiekty r贸偶nych typ贸w (osoby, rodziny, ...) s ze sob wymieszane. To bardzo utrudnia wizualizacj r贸偶nic w plikach, bo narzdzia to szukania r贸偶nic, nie znajc struktury pliku GEDCOM, pokazuj czsto r贸偶nice midzy r贸偶nymi typami danych.

Zaczem wic od drobnych porzdk贸w - posortowaem obiekty po typie i identyfikatorze. GEDKeeper stosuje identyfikatory w formacie `@AXXXX`, gdzie `A` to litera oznaczajca typ obiektu (np. `I` dla osoby, `F` dla rodziny), a `XXXX` to numer porzdkowy. Dziki temu atwiej jest por贸wnywa obiekty tego samego typu. atwiej tak偶e rozr贸偶ni gdzie kocz si obiekty zmieniane a zaczynaj nowe, nie istniejce w drugim pliku.

Oczywicie nie robiem tego rcznie, bo rczne przenoszenie po kilkakilkanacie linii tekstu w pliku zawierajcym ich ponad 40 tysicy to samob贸jstwo. Napisaem prosty skrypt w JavaScript, kt贸ry sortuje plik GEDCOM wedug typu obiektu i identyfikatora. Skrypt ten mo偶na uruchomi w Node.js, a jego dziaanie jest proste - odczytuje plik, sortuje obiekty i zapisuje wynik do nowego pliku. O ile przedstawione tu skrypty tworzyem sam, o tyle metodyk, problemy i pomysy na ich rozwizanie "omawiaem" z ChatGPT.

**UWAGA: Przed przystpieniem do rcznego modyfikowania plik贸w GEDCOM warto zrobi ich kopi zapasow w innym miejscu. Mo偶na tak偶e stworzy lokalne repozytorium git w folderze z drzewem i zacommitowa aktualn wersj drzewa - w przyszoci mo偶na dodawa osobne commity po ka偶dej partii zmian, co uatwia synchronizacj i przeledzenie zmian.**

<details>
<summary>U偶yty przeze mnie skrypt JS do sortowania pliku GEDCOM</summary>
```js
function sortFile(file) {
    const fs = require('node:fs');
    const path = require('node:path');
    const data = fs.readFileSync(file, 'utf8');
    const [header1, header2, ...rest] = data.split(/\r?\n/);
    const footer = rest.pop();

    const sorted = rest
        .map(line => [line.split(/\r?\n/)[0].split(' '), line])
        .map(([[_, id, type], item]) => ({ type, id, numId: +id.match(/\d+/g)[0], item }))
        .sort((a, b) => a.type.localeCompare(b.type) || a.numId - b.numId)
        .map(i => i.item);

    const finalContent = [header1, header2, ...sorted, footer].join('\r\n');
    
    const newName = path.basename(file, '.ged') + '-sorted.ged';
    const newPath = path.join(path.dirname(file), newName);
    fs.writeFileSync(newPath, sorted, 'utf8');
}
sortFile('/full/path/to/file-1.ged');
sortFile('/full/path/to/file-2.ged');
```
</details>

## Metodyka i kolejno dziaania.

Majc posortowane pliki, mogem przystpi do rcznego ich czenia.

Wszystkie zmiany wykonywaem w VSCode (Notepad++ te偶 by zadziaa) majc otworzone oba pliki GEDCOM jeden obok drugiego w widoku wyr贸偶niania r贸偶nic. Zmiany kopiowaem zawsze w obie strony - moim celem byo uzyskanie dw贸ch identycznych plik贸w zawierajcych wszystkie zmiany - w ten spos贸b bybym w stanie potwierdzi skuteczne poczenie plik贸w.

GEDKeeper zapisuje nastpujce typy obiekt贸w w pliku GEDCOM:
- Osoby (identyfikator `@Ixxx@`, typ `INDI`)
- Rodziny (identyfikator `@Fxxx@`, typ `FAM`)
- Notatki (identyfikator `@Nxxx@`, typ `NOTE`)
- 殴r贸da (identyfikator `@Sxxx@`, typ `SOUR`)
- Multimedia (identyfikator `@Oxxx@`, typ `OBJE`)
- Lokalizacje (identyfikator `@Lxxx@`, typ `_LOC` - typ niestandardowy u偶ywany przez GEDKeeper)

Istotne jest to, 偶e niekt贸re z tych obiekt贸w mog zawiera identyfikatory innych obiekt贸w, np. osoba mo偶e mie referencje do rodziny (swojej jako partner lub swoich rodzic贸w jako dziecko). Zar贸wno osoby jak i rodziny mog si odnosi w ten spos贸b do ka偶dego innego typu.

Zaczem od czenia 4 ostatnich typ贸w, czyli notatek, 藕r贸de, multimedi贸w i lokalizacji, kt贸re nie zawieraj referencji do innych obiekt贸w. Byo to proste, gdy偶 nie byo 偶adnych zmian notatek i multimedi贸w. W przypadku lokalizacji i 藕r贸de, w obu plikach powstao po kilka nowych wpis贸w. GEDKeeper stosuje kolejne liczby w identyfikatorach, co oznacza 偶e w obu plikach powstaway 藕r贸da i lokalizacje z tymi samymi kolejnymi identyfikatorami - wystarczyo wic w jednym z plik贸w doda do tych numer贸w 1000 (zmieniajc np. `@L123` na `@L1123` - wa偶ne: **w caym pliku!**), a nastpnie skopiowa nowe wpisy z ka偶dego z tych plik贸w do drugiego.

O ile og贸lna zasada pozostawaa taka sama dla os贸b i rodzin, o tyle wymagaa ona dokadniejszego planu i sprawdzania zmian, ze wzgldu na to, 偶e osoby i rodziny mog zawiera wiele referencji na raz i tworzy bardzo skomplikowane siatki odniesie (rodzina F1 ma odniesienie do os贸b I1, I2, I3, ka偶da z tych os贸b zawiera odniesienie do F1, ale tak偶e i innych rodzin...).

<figure>
![](example-presort.png)
<figcaption>Chaos przy por贸wnywaniu dw贸ch plik贸w GEDCOM</figcaption>
</figure>


<details>
<summary>Jak wygldaj odniesienia midzy osobami i rodzinami w GEDCOM</summary>

Osoby wskazuj rodziny na dwa sposoby:

```gedcom
0 @I1@ INDI
1 FAMC @F1@
1 FAMS @F2@
```

- FAMC - rodzina F1 zawiera rodzic贸w (i rodzestwo) osoby I1.
- FAMS - rodzina F2 zawiera partnera i dzieci osoby I1.

Zar贸wno FAMC jak i FAMS mog pojawi si w danej osobie zero, jeden lub wicej razy.

Analogicznie, rodziny wskazuj osoby na kilka sposob贸w:

```gedcom
0 @F1@ FAM
1 WIFE @I1@
1 HUSB @I2@
1 CHIL @I3@
1 CHIL @I4@
1 CHIL @I5@
```

- WIFE i HUSB to odpowiednio 偶ona (I1) i m偶 (I2); mog si pojawi zero (gdy partner jest nieznany) lub jeden raz.
- CHIL to dzieci tej rodziny (tu tr贸jka dzieci: I3, I4 i I5)
</details>

Dwa spacery z psem i jeden kubek kawy p贸藕niej, doszedem do wniosku jak najlepiej wzi si za ten problem.

1. Poczy zmiany w istniejcych osobach, ale nie kopiujc jeszcze odniesie do rodzin (czyli pozostawiajc r贸偶nice w tagach FAMC i FAMS nietknite).
2. W jednym z plik贸w dla ka偶dej nowej osoby zwikszy identyfikator o 10000 (w caym pliku na raz - opcja Zamie wszystko)
3. Przekopiowa nowe osoby z ka偶dego z tych plik贸w do drugiego, ale bez kopiowania odniesie do rodzin (bo te identyfikatory mog mie kolizje).
4. Poczy zmiany w istniejcych rodzinach.
5. W jednym z plik贸w dla ka偶dej nowej rodziny zwikszy identyfikator o 1000 (ponownie w caym pliku na raz)
6. Przekopiowa nowe rodziny z ka偶dego z tych plik贸w do drugiego
7. Przekopiowa reszt r贸偶nic w osobach (czyli odniesienia do rodzin) z ka偶dego z tych plik贸w do drugiego.

W ostatnim kroku, jeli pojawiby si konflikt (np ta sama osoba w jednym pliku wskazuje na inn rodzin ni偶 w drugim), oznaczaoby to duplikacj rodziny (jedna rodzina dodana dwa razy). Analogicznie w przypadku konfliktu z osobami wskazanymi w rodzinie mo偶e to oznacza duplikacj osoby (g贸wnie w przypadku partnera).

## Po zakoczeniu wszystkich krok贸w 

Caa ta zabawa zaja dwa dugie weekendowe wieczory. W jej wyniku uzyskaem dwa identyczne pliki GEDCOM. To jeszcze nie oznaczao skoczonej zabawy - taki plik musia si poprawnie otworzy w programie genealogicznym (bez 偶adnych bd贸w). Postanowiem jednak dokona jednej rcznej weryfikacji przed uruchamianiem GedKeepera. Uznaem, 偶e nale偶y sprawdzi poprawno odniesie - 偶e wskazywane przez osoby rodziny istniej, 偶e osoby wskazywane przez rodziny istniej, oraz 偶e rodziny i osoby prawidowo wskazuj na siebie nawzajem. Ponownie u偶yem do tego skryptu nodeJS

<details>
<summary>U偶yty przeze mnie skrypt JS do weryfikacji odniesie w pliku GEDCOM</summary>
```js
function checkCrossReferences(file) {
    let readErrs = 0, refErrs = 0;

    const fs = require('node:fs');
    const data = fs.readFileSync(file, 'utf8');
    const { INDI, FAM } = data
        .split(/\r?\n(?=0 )/g)
        .map(line => [line.split(/\r?\n/)[0].split(' '), line])
        .map(([[_, id, type], item]) => ({ type, id, item: /** @type {string} */(item) }))
        .reduce(
            (acc, { type, id, item }) => {
                if (!(type === 'INDI' || type === 'FAM')) {
                    return acc;
                }
                acc[type][id] = { item, references: [] };
                const references = acc[type][id].references;
                switch (type) {
                    case 'INDI': {
                        const matches = item.match(/^1 FAM[CS] @F(\d+)@$/mg);
                        if (matches) {
                            matches.forEach(match => {
                                const [_, type, id] = match.split(' ');
                                if (references.some(ref => ref.id === id)) {
                                    console.error(`Duplicate reference found for INDIVIDUAL ${id} in FAMILY ${type}.`);
                                    readErrs++;
                                }
                                references.push({ type, id });
                            });
                        }
                        break;
                    }
                    case 'FAM': {
                        const matches = item.match(/^1 (HUSB|WIFE|CHIL) @I(\d+)@$/mg);
                        if (matches) {
                            matches.forEach(match => {
                                const [_, type, id] = match.split(' ');
                                if (references.some(ref => ref.id === id)) {
                                    console.error(`Duplicate reference found for FAMILY ${id} in INDIVIDUAL ${type}.`);
                                    readErrs++;
                                }
                                references.push({ type, id });
                            });
                        }
                        break;
                    }
                }
                return acc;
            },
            { INDI: {}, FAM: {} }
        );

    for(const id in INDI) {
        const indi = INDI[id];
        indi.references.forEach(ref => {
            if (!FAM[ref.id]) {
                console.error(`Cross-reference error: INDIVIDUAL ${id} references non-existent FAMILY ${ref.id}.`);
                refErrs++;
            } else {
                const crossRefs = FAM[ref.id].references.filter(r => r.id === id);
                if (crossRefs.length === 0) {
                    console.error(`Cross-reference error: FAMILY ${ref.id} does not reference INDIVIDUAL ${id}.`);
                    refErrs++;
                } else if (crossRefs.length > 1) {
                    console.error(`Cross-reference error: FAMILY ${ref.id} references INDIVIDUAL ${id} multiple times.`, crossRefs);
                    refErrs++;
                }
            }
        });
    }
    for(const id in FAM) {
        const fam = FAM[id];
        fam.references.forEach(ref => {
            if (!INDI[ref.id]) {
                console.error(`Cross-reference error: FAMILY ${id} references non-existent INDIVIDUAL ${ref.id}.`);
                refErrs++;
            } else {
                const crossRefs = INDI[ref.id].references.filter(r => r.id === id);
                if (crossRefs.length === 0) {
                    console.error(`Cross-reference error: INDIVIDUAL ${ref.id} does not reference FAMILY ${id}.`);
                    refErrs++;
                } else if (crossRefs.length > 1) {
                    console.error(`Cross-reference error: INDIVIDUAL ${ref.id} references FAMILY ${id} multiple times.`, crossRefs);
                    refErrs++;
                }
            }
        });
    }

    console.log(`\nFINAL REPORT for file ${file}:`);
    console.log(`Checked ${Object.keys(INDI).length} individuals and ${Object.keys(FAM).length} families.`);
    console.log(`Read errors: ${readErrs}`);
    console.log(`Cross-reference errors: ${refErrs}`);
}
checkCrossReferences('/full/path/to/file-1.ged');
checkCrossReferences('/full/path/to/file-2.ged');
```
</details>

## Nauczka na przyszo:

1. Pracuj tylko na jednej g贸wnej kopii drzewa i synchronizuj j od razu po zakoczeniu pracy
2. Przechowuj drzewo w repozytorium git, aby mie histori zmian drzewa genealogicznego
3. Jeli u偶ywanie nodeJS do pracy z plikami GEDCOM wydaje si gupie, ale dziaa, to znaczy 偶e nie jest gupie
